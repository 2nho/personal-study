기존 프로젝트의 수정을 하던 중 string.indexOf()를 통해 
해당 값이 존재하는지 안하는지 확인하는 절차를 거치는 것을 보았다.

기존 코드를 수정하며 기능을 확장하기 위해 위 기능을 나도
이용해보고자 mdn을 통해 공식문서를 읽어 사용법을 숙지한 후  
기존 코드를 수정했는데 계속 -1이 반환되며 값을 못찾아 조건문을
타지 못해 원인을 찾지 못해 몇시간을 허비만 했다.
이후 집에 와서 다시 유심히 살펴봤지만 아무리 봐도 로직은
틀리지 않은거 같은데 원하는 결과값이 나오지 않아 골머리를 앓았다.

해당 프로젝트에서 조건문의 조건값으로 A.indexOf(해당값) 을 이용하고
있었는데 기존 화면에서 조건값으로 잘 구현되고 있어서 의심하지 않았었다.
하지만 막상 기능을 확장하면서 원하는 결과로 return되지 않아 indexOf가
로직에서 한번만 실행이 가능한 것인가? 하는 멍청한 생각부터 해서
어딘가에 괄호가 빠졌나? if else if문 작성중에 실수가 있었나에 대해서만
생각했었다. 그러다 문득 혹시 넣어주는 A의 값이 String이 아닌가에 대해
생각하게 됐고 콘솔을 찍어 확인해보니 []배열 형태로 나타나는 것을 확인했다.
그래서 배열의 값을 loop문을 통해 하나씩 빼내 string형태로 이어붙여
원하는 값을 도출할 수 있었다! 

외주업체 경력높은 인도인이 짠 코드를 해석하면서 기능을 확장하거나 오류를
수정하고 있는데 아직 1개월 겨우 된 신입으로서 살짝 고되다.. 
+ 기존코드에서 배열에 indexOf를 사용했던 부분에서는
if(A.indexOf(값)<0) { 로직 } 이였기에 항상 true였다 ㅠ
근데 또 구현한 로직에는 신기하게 맞아돌아갔기에 저 부분을 의심하는데 
오랜시간이 걸렸다 ..

+ 하지만..
array.indexOf가 있었다 
다시 오류의 이유를 찾아보니 indexOf가 === 로 비교하기에 type까지 정확히 맞아야 했다.
ajax를 통해 받아오는 값이 [num,num] 형태였기 때문에 string 형태의 값으로 선언했던 것을 parseint로 변환을 해주어야 했다. 

MDN설명
indexOf()는 엄격한 동등성 (=== 또는 triple-equals 연산자에서 사용하는 것과 같은 메서드)을 사용하여 검색 요소를 Array의 요소와 비교합니다.

