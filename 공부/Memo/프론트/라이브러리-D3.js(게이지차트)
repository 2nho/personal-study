let data = [
	  { "value": 3.5, "fill": "#4caf51", "sortIndex": 0 },
	  { "value": 1.5, "fill": "#e1e8f3", "sortIndex": 1 }
	]
let gChart = MetricGauge(data);
$("#gaugeChart").append(gChart);
function MetricGauge(data, options) {
	  const { elDom, arcThickness, size, transitionDuration } = Object.assign(
	    {
	      arcThickness: 12,
	      size: 150,
	      transitionDuration: 800
	    },
	    options
	  );

	  const t = d3.transition().duration(350);

	  const arc = d3
	    .arc()
	    .innerRadius(size / 2 - arcThickness)
	    .outerRadius(size / 2)
	    .cornerRadius(arcThickness);

	  const pie = d3
	    .pie()
	    .value(d => d.value)
	    .startAngle(-Math.PI / 1.45)
	    .endAngle(Math.PI / 1.45)
	    .sort((a, b) => d3.ascending(a.sortIndex, b.sortIndex));
	 console.log(data)
	  const initData = pie(JSON.parse(JSON.stringify(data)));
	  const arcs = pie(data);
	  
	  function arcTween(d, bIsLastArc) {
	  
	    var interpolateStart = d3.interpolate(-Math.PI / 1.45, d.startAngle);
	    var interpolateEnd = d3.interpolate(
	      bIsLastArc ? d.endAngle : -Math.PI / 1.45,
	      d.endAngle
	    );  
	    return function(t) {
	     
	      d.startAngle = interpolateStart(t);
	      d.endAngle = interpolateEnd(t);
	      return arc(d);
	    };
	  }

	  const svg = d3
	    .create("svg")
	    .classed("metric-gauge", true)
	    .attr("viewBox", [-size / 2, -size / 2, size, size]);

	  // add def and drop shadow for the value dot
	  svg.append("defs")
	    .html(`<filter id="dot-shadow" x="-50%" y="-50%" width="200%" height="200%" filterUnits="objectBoundingBox">
	      <feDropShadow dx="3" dy="3" stdDeviation="8" flood-color="${initData[0].data.fill}" flood-opacity="0.25" />
	    </filter>`);
	  
	  const gauges = svg
	    .selectAll("path")
	    .data(arcs)
	    .join("path")
	    .attr("fill", d => d.data.fill)
	    .attr("d", arc);

	  gauges
	    .transition()
	    .duration(transitionDuration)
	    .attrTween("d", (d, i) => arcTween(d, i == arcs.length - 1));

	  // Add a dot to mark the end of the first arc
	  const dot = svg
	    .selectAll("circle")
	    .data([
	      Object.assign(initData[0], {
	        startAngle: initData[0].endAngle,
	        endAngle: initData[1].startAngle,
	        stroke: initData[initData.length - 1].data.fill
	      })
	    ])
	    .join("circle")
	    .attr("fill", "#fff")
	    .attr("r", arcThickness * 0.95)
	    .attr("stroke", d => d.stroke)
	    .attr("stroke-width", 0.1)
	    .attr("style", "filter:url(#dot-shadow)")
	    .attr("transform", d => `translate(${arc.centroid(d)})`);

	  dot
	    .transition()
	    .duration(transitionDuration)
	    .attrTween("transform", d => {
	      const interpolateStart = d3.interpolate(-Math.PI / 1.45, d.startAngle);
	      const interpolateEnd = d3.interpolate(-Math.PI / 1.45, d.endAngle);
	      return function(t) {
	        d.startAngle = interpolateStart(t);
	        d.endAngle = interpolateEnd(t);
	        return `translate(${arc.centroid(d)})`;
	      };
	    });

	  const arcValue = d3
	    .arc()
	    .innerRadius(0)
	    .outerRadius(size / 2);

	  svg
	    .append("text")
	    .attr("transform", `translate(0, ${(0.1 * size) / 2})`)
	    .attr("font-size", 30)
	    .attr("text-anchor", "middle")
	    .attr("fill", data[0].fill)
	    .text(data[0].value);
	  
	    svg
	    .append("text")
	    .attr("transform", `translate(0, ${(0.1 * size)+10})`)
	    .attr("font-size", 12)
	    .attr("text-anchor", "middle")
	    .attr("fill", data[0].fill)
	    .text("제한자");
	  	

	  if (elDom) {
	    elDom.innerHTML = svg.node().innerHTML;
	  }

	  return svg.node();
	}
