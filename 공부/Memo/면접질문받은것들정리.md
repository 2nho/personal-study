# 상태코드 
 HTTP 상태 코드 분류
 => 2 , 4 , 5 는 말했는데 3은 기억안나서 말못함 ㅠㅠ..   
 
1xx (Informational) : 조건부 응답  
2xx (Successful) : 성공  
3xx (Redirection) : 리다이렉션 완료  
4xx (Client Error) : 요청 오류  
5xx (Server Error) : 서버 오류  
 
# 동시성 병렬화 차이 
 => 아예 개념을 잘몰라서 이상하 대답함
목표
동시성 : 작업을 동시에 수행하는 것처럼 보이도록 하는 것
병렬화 : 작업을 실제로 동시에 수행하는 것

수행 방법
동시성 : 하나의 코어에서 여러 개의 작업을 번갈아 가며 수행하도록 스케줄링
병렬화 : 여러 개의 코어에서 작업을 동시에 수행

활용 분야
동시성 : 주로 I/O 작업, 이벤트 처리, UI 처리 등의 분야에서 활용
병렬화 : CPU 집약적인 작업, 데이터 처리, 계산 등의 분야에서 활용
처리 단위

동시성 : 스레드(Thread), 태스크(Task) 등의 작은 단위로 처리
병렬화 : 프로세스(Process), 스레드(Thread) 등의 큰 단위로 처리
확장성

동시성 : 스레드 수가 증가해도 처리량이 늘어나지 않는 경우가 있으므로, 확장성이 떨어질 수 있음
병렬화 : 코어 수가 증가하면 처리량도 비례해서 증가하므로, 확장성이 높음
오버헤드

동시성 : 스레드 간의 상호작용, 동기화 등으로 인해 오버헤드가 발생할 수 있음
병렬화 : 데이터 분할, 코어 간의 통신 등으로 인해 오버헤드가 발생할 수 있음

# 쓰레드와 프로세스 차이   
=> 완전 이상하게 말함 .. 프로세스는 한가지 일만하고 쓰레드는 여러개의 일을 할 수 있다는 둥..   
정의
쓰레드 : 하나의 프로세스 내에서 실행되는 여러 개의 실행 단위
프로세스 : 운영체제로부터 자원(메모리, 입출력 등)을 할당받아 실행 중인 프로그램

자원 공유
쓰레드 : 하나의 프로세스 내에서 공유하는 자원(메모리, 파일 등)을 직접 접근할 수 있음
프로세스 : 운영체제로부터 독립적인 자원을 할당받아 사용하므로, 자원 공유를 위해서는 별도의 메커니즘(파이프, 소켓 등)이 필요함

생성
쓰레드 : 프로세스 내에서 쓰레드를 생성하는 것이 가능함
프로세스 : 운영체제로부터 새로운 자원을 할당받아 프로세스를 생성하는 것이 필요함

경량화
쓰레드 : 하나의 프로세스 내에서 실행되므로, 생성 및 삭제 비용이 낮아 경량화(Lightweight)되어 있음
프로세스 : 운영체제로부터 자원을 할당받아 실행되므로, 생성 및 삭제 비용이 높아 무거움(Heavyweight)

독립성
쓰레드 : 하나의 프로세스 내에서 실행되기 때문에 다른 쓰레드에 영향을 받을 수 있음
프로세스 : 운영체제로부터 독립적인 자원을 할당받아 실행되기 때문에, 다른 프로세스에 영향을 받지 않음

CPU 활용
쓰레드 : 하나의 프로세스 내에서 실행되기 때문에, CPU 자원을 공유하므로 더 효율적인 CPU 활용이 가능함
프로세스 : 다른 프로세스와 자원을 공유하지 않기 때문에, CPU 자원을 독점적으로 사용해야 하므로 CPU 활용 면에서 제한적임

![image](https://github.com/2nho/personal-study/assets/97571604/64362b86-6580-4e0c-b556-fa8404b2ff6f)




# 시간복잡도(중요 너무 부족함 개념)
 hashMap 과 linkedList에서 추가 삭제가 일어날때의 시간복잡도 
 
 - HashMap에서 요소를 추가, 삭제, 검색하는 연산의 시간 복잡도는 평균 O(1)
 - LinkedList에서 [리스트의 맨 앞에 요소를 추가하는 경우 : O(1),  
                  리스트의 중간에 요소를 추가하는 경우 : 해당 요소를 찾기 위해 O(n)의 시간이 소요되며,   
                  요소를 추가하는 데는 O(1)의 시간이 소요됨. 따라서, 총 시간 복잡도는 O(n)  
                  리스트의 끝에 요소를 추가하는 경우 : O(1)  
                  => 삭제도 이와동일]  

# 문제점찾기
1. 이 코드의문제점은 무엇이고 개선하면 어떻게 할 것인가
``` 
private List<String> metaData = Lists.newArrayList("book","apple","noteBook","orange","car","bus",.......n);
 
public boolean isContainKey(String key) {
  for(String metaKey: metaData) {
    if(metaKey.equals(key)) {  
    return true;            
    }       
  }      
  return false;
}
```
내 대답 : private , public언급 그저 , hashmap사용..?

아마원한대답
```
private Set<String> metaData = new HashSet<>(Arrays.asList("book","apple","noteBook","orange","car","bus",...));
 
public boolean isContainKey(String key) {
  return metaData.contains(key);
}
```
=> 리스트의 커질 경우 성능문제로 이어지기 때문에 hashSet같은 자료구조로 변경 

2. 시간복잡도는 몇인가
내 대답 : if문까지해서 2N..? 그저 .. 똥멍청이 for문하나만 생각하면 되는데 앞에서 다틀린거같으니 뇌정지와서 if를 왜고려했지

정답 : O(n)


* private , public언급한건 진짜.. 용납못할거 같긴한다  

이 코드에서 metaData는 private이지만, isContainKey는 public인 이유는 클래스의 캡슐화(encapsulation) 원칙

캡슐화는 객체 지향 프로그래밍의 핵심 개념 중 하나로, 데이터와 그 데이터를 처리하는 메서드를 하나의 단위로 묶는 것을 의미합니다. 이렇게 함으로써 객체 내부의 데이터에 직접 접근하는 것을 제한하고, 데이터의 일관성과 안전성을 유지

따라서, 클래스 내부의 데이터는 보통 private으로 선언하고, 해당 데이터를 사용하는 메서드는 public으로 선언하여 외부에서 해당 메서드를 통해 데이터에 접근할 수 있도록 함 
이렇게 함으로써 클래스 외부에서는 클래스 내부의 데이터에 직접 접근하지 않아도 되므로, 데이터의 무결성을 유지 가능!

따라서, 이 코드에서 metaData는 private으로 선언하여 클래스 외부에서는 직접 접근하지 못하게 하고, isContainKey는 public으로 선언하여 클래스 외부에서 해당 메서드를 호출하여 metaData를 검색할 수 있도록 합니다.

후기 : 분발해야지.. 걍 똥멍청이 코더 였을뿐이였다 , 라이브러리 까며 공부한답시고 시간 버리지말구 기초부터.. 하기! 편입하려는 마음도 ..  굳건해졌다.. 

근데 확실히 털리니 머리에 잘 박히긴한다. 
